<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: paint.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: paint.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Underlay draing for System Mapper
 * @author Nigel Gilbert
 * @email n.gilbert@surrey.ac.uk
 * @date June 2020
 *
 * After setup, when user selects a tool form the toolbox, the mouse is used to paint on the tem canvas
 * when the tool is finished, a set of painting commands is stored; then those commands are used to redraw the main canvas.
 *
 */

/**
 * Initialisation
 */

/* default canvas attributes */
let iniLineWidth = 2;
let iniStrokeStyle = '#000000';
let iniFillStyle = '#ffffff';
let iniFont = '16px sans-serif';
let iniFontColor = '#000000';
let iniAlpha = 1.0;
let iniComposite = 'source-over';

let selectedTool = null;

/* globals */
let underlay;
let mainCanvas;
let mainctx;
let tempCanvas;
let tempctx;
let points = [['endShape']];

window.points = points;

window.addEventListener('load', () => {
	setUpPaint();
	setUpToolbox();
});
/**
 * create the canvases and add listeners for mouse events
 */
function setUpPaint() {
	underlay = document.getElementById('underlay');
	mainCanvas = setUpCanvas('main-canvas');
	mainctx = getContext(mainCanvas);
	tempCanvas = setUpCanvas('temp-canvas');
	tempctx = getContext(tempCanvas);

	tempCanvas.addEventListener('mousedown', mouseDespatch);
	tempCanvas.addEventListener('mousemove', mouseDespatch);
	tempCanvas.addEventListener('mouseup', mouseDespatch);
}
/**
 * set up and return the canvas at the id
 * @param {string} id - canvas id
 */
function setUpCanvas(id) {
	const canvas = document.getElementById(id);
	// Get the device pixel ratio, falling back to 1.
	let dpr = window.devicePixelRatio || 1;
	// Get the size of the canvas in CSS pixels.
	let rect = canvas.getBoundingClientRect();
	// Give the canvas pixel dimensions of their CSS size * the device pixel ratio.
	canvas.width = rect.width * dpr;
	canvas.height = rect.height * dpr;
	return canvas;
}

/**
 * return the context for the provided canvas
 * @param {canvas} canvas
 */
function getContext(canvas) {
	let ctx = canvas.getContext('2d');
	let dpr = window.devicePixelRatio || 1;
	ctx.scale(dpr, dpr);
	ctx.lineWidth = iniLineWidth;
	ctx.strokeStyle = iniStrokeStyle;
	ctx.fillStyle = iniFillStyle;
	ctx.font = iniFont;
	ctx.lineJoin = 'round';
	ctx.lineCap = 'round';
	return ctx;
}

/**
 * add listeners for when the tool buttons are clicked
 */
function setUpToolbox() {
	let tools = document.querySelectorAll('.tool');
	Array.from(tools).forEach((tool) => {
		tool.addEventListener('click', selectTool);
	});
}
/**
 *
 * Toolbox
 */
/**
 * event listener: when user clicks a tool icon
 * unselect previous tool, select this one
 * and remember which tool is now selected
 * The undo and image tools are special, because they act
 * immediately when the icon is clicked
 * 
 * @param {object} event
 */
function selectTool(event) {
	let tool = event.currentTarget;
	if (tool.id == 'undo') {
		undoHandler.undo();
		// previous tool remains selected
		return;
	}
	//second click on selected tool
	if (selectedTool === tool.id) {
		if (event.target.className == 'triangle-bottomright') {
			// display options dialog
			toolHandler(selectedTool).optionsDialog();
		} else {
			// second click - unselect all tools
			if (selectedTool) {
				document.getElementById(selectedTool).classList.remove('selected');
			}
			selectedTool = null;
		}
		return;
	}
	// changing tool; unselect previous one
	if (selectedTool) {
		document.getElementById(selectedTool).classList.remove('selected');
	}
	selectedTool = tool.id;
	tool.classList.add('selected');
	closeOptionsDialogs();
	if (event.target.className == 'triangle-bottomright') {
		// display options dialog
		toolHandler(selectedTool).optionsDialog();
	}
}

/**
 * close/hide any option dialog that is open
 */
function closeOptionsDialogs() {
	let dialogs = document.querySelectorAll('.options');
	Array.from(dialogs).forEach((dialog) => {
		dialog.style.display = 'none';
	});
}
/**
 * despatch to and perform tool actions
 */

/**
 * all mouse events are handled here - despatch to the selected tool
 * @param {object} event
 */
function mouseDespatch(event) {
	event.preventDefault();
	if (!selectedTool) return;
	toolHandler(selectedTool)[event.type](event);
}

/**
 * deal with each tool, managing mouse events appropriately
 * yields drawing commands in points[] that record what the effect of
 * each tool is
 */

 /**
  * superclass for all tool handlers
  */
class ToolHandler {
	constructor() {
		this.isMouseDown = false;
		this.startX = 0;
		this.startY = 0;
		this.endX = 0;
		this.endY = 0;
		this.strokeStyle = iniStrokeStyle;
		this.fillStyle = iniFillStyle;
		this.lineWidth = iniLineWidth;
		this.font = iniFont;
		this.globalAlpha = iniAlpha;
		this.globalCompositeOperation = iniComposite;
	}
	/**
	 * mouse has been pressed - note the starting mouse position
	 * @param {event} e 
	 */
	mousedown(e) {
		this.endPosition(e);
		this.startX = this.endX;
		this.startY = this.endY;
		this.isMouseDown = true;
	}
	/**
	 * note the mouse coordinates relative to the canvas
	 * @param {event} e 
	 */
	endPosition(e) {
		this.endX = e.offsetX - tempCanvas.offsetLeft;
		this.endY = e.offsetY - tempCanvas.offsetTop;
	}
	/**
	 * do something as the nouse moves
	 */
	mousemove() { }
	/**
	 * mouseup means the shape has been completed - add a marker to reord that 
	 */
	mouseup() {
		points[points.length] = ['endShape'];
	}
	/**
	 * return an object with the current canvas drawing options, either those chosen by the user,
	 * or th defaults
	 */
	options() {
		return {
			strokeStyle: this.strokeStyle || iniStrokeStyle,
			fillStyle: this.fillStyle || iniFillStyle,
			lineWidth: this.lineWidth || iniLineWidth,
			font: this.font || iniFont,
			globalAlpha: this.globalAlpha || iniAlpha,
			globalCompositeOperation:
				this.globalCompositeOperation || iniComposite,
		};
	}
	/**
	 * create a dialog box to allow the user to choose options for the current shape
	 * sub classes fill the box with controls
	 * @param {string} tool 
	 */
	optionsDialog(tool) {
		let box = document.createElement('div');
		box.className = 'options';
		box.style.top =
			document.getElementById(tool).getBoundingClientRect().top -
			underlay.getBoundingClientRect().top +
			'px';
		box.style.left =
			document.getElementById(tool).getBoundingClientRect().right +
			10 +
			'px';
		underlay.appendChild(box);
		return box;
	}
}

/* ========================================================== line ================================================ */

class LineHandler extends ToolHandler {
	constructor() {
		super();
		this.axes = false;
	}
	mousemove(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			if (this.axes) {
				if (this.endX - this.startX > this.endY - this.startY)
					this.endY = this.startY;
				else this.endX = this.startX;
			}
			drawHelper.clear(tempctx);
			drawHelper.line(tempctx, this.options(), [
				this.startX,
				this.startY,
				this.endX,
				this.endY,
			]);
		}
	}
	mouseup() {
		if (this.isMouseDown) {
			points[points.length] = [
				'line',
				this.options(),
				[this.startX, this.startY, this.endX, this.endY],
			];
			this.isMouseDown = false;
			super.mouseup();
			redraw();
		}
	}
	optionsDialog() {
		let box = super.optionsDialog('line');
		box.innerHTML = `
	&lt;div>Line width&lt;/div>&lt;div>&lt;input id="lineWidth" type="text" size="2">&lt;/div>
	&lt;div>Colour&lt;/div>&lt;div>&lt;input id="lineColour" type="color">&lt;/div>
	&lt;div>Axes&lt;/div>&lt;div>&lt;input type="checkbox" id="axes">&lt;/div>
	&lt;div>&lt;/div>&lt;div class="right">&lt;button id="lineDone">Done&lt;/button>&lt;/div>`;
		let widthInput = document.getElementById('lineWidth');
		widthInput.value = this.lineWidth;
		widthInput.focus();
		document.getElementById('lineColour').value = this.strokeStyle;
		document.getElementById('axes').checked = this.axes;
		// listener for when Done button is pressed
		document.getElementById('lineDone').addEventListener('click', () => {
			this.lineWidth = parseInt(widthInput.value);
			this.strokeStyle = document.getElementById('lineColour').value;
			this.axes = document.getElementById('axes').checked;
			underlay.removeChild(box);
		});
	}
}
let lineHandler = new LineHandler();

/* ========================================================== rect ================================================ */

class RectHandler extends ToolHandler {
	constructor() {
		super();
	}
	mousedown(e) {
		super.mousedown(e);
		underlay.style.cursor = 'crosshair';
	}
	mousemove(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			drawHelper.clear(tempctx);
			drawHelper.rect(tempctx, this.options(), [
				this.startX,
				this.startY,
				this.endX - this.startX,
				this.endY - this.startY,
			]);
		}
	}
	mouseup() {
		if (this.isMouseDown) {
			points[points.length] = [
				'rect',
				this.options(),
				[
					this.startX,
					this.startY,
					this.endX - this.startX,
					this.endY - this.startY,
				],
			];
			this.isMouseDown = false;
			underlay.style.cursor = 'auto';
			super.mouseup();
			redraw();
		}
	}
	optionsDialog() {
		let box = super.optionsDialog('rect');
		box.innerHTML = `
	&lt;div>Border width&lt;/div>&lt;div>&lt;input id="borderWidth" type="text" size="2">&lt;/div>
  &lt;div>Border Colour&lt;/div>&lt;div>&lt;input id="borderColour" type="color">&lt;/div>
  &lt;div>Fill Colour&lt;/div>&lt;div>&lt;input id="fillColour" type="color">&lt;/div>
  &lt;div>&lt;/div>&lt;div class="right">&lt;button id="rectDone">Done&lt;/button>&lt;/div>`;
		let widthInput = document.getElementById('borderWidth');
		widthInput.value = this.lineWidth;
		widthInput.focus();
		document.getElementById('borderColour').value = this.strokeStyle;
		document.getElementById('fillColour').value = this.fillStyle;
		document.getElementById('rectDone').addEventListener('click', () => {
			this.lineWidth = parseInt(widthInput.value);
			this.strokeStyle = document.getElementById('borderColour').value;
			this.fillStyle = document.getElementById('fillColour').value;
			underlay.removeChild(box);
		});
	}
}
let rectHandler = new RectHandler();

/* ========================================================== text ================================================ */
class TextHandler extends ToolHandler {
	constructor() {
		super();
		this.inp = null;
		this.writing = false;
		this.font = iniFont;
		this.fillStyle = iniFontColor;
	}
	mousedown(e) {
		if (this.writing) return;
		this.startX = e.offsetX - tempCanvas.offsetLeft;
		this.startY = e.offsetY - tempCanvas.offsetTop;
		this.inp = document.createElement('input');
		underlay.appendChild(this.inp);
		this.inp.setAttribute('id', 'input');
		this.inp.setAttribute('type', 'text');
		this.inp.style.font = this.font;
		this.inp.style.color = this.fillStyle;
		this.inp.style.position = 'absolute';
		this.inp.style.left = this.startX + 'px';
		this.inp.style.top = this.startY + 'px';
		this.inp.style.zIndex = 1002;
		this.inp.addEventListener(
			'change',
			(e) => {
				this.saveText(e);
			},
			{once: true}
		);
		this.writing = true;
		underlay.style.cursor = 'text';
		this.inp.focus();
	}
	saveText() {
		points[points.length] = [
			'text',
			this.options(),
			[this.inp.value, this.startX, this.startY],
		];
		this.writing = false;
		underlay.removeChild(this.inp);
		underlay.style.cursor = 'auto';
		super.mouseup();
		redraw();
	}
	optionsDialog() {
		let box = super.optionsDialog('text');
		box.innerHTML = `
	&lt;div>Size&lt;/div>&lt;div>&lt;input id="fontSize" type="text" size="2">&lt;/div>
	&lt;div>Colour&lt;/div>&lt;div>&lt;input id="fontColor" type="color">&lt;/div>
	&lt;div>&lt;/div>&lt;div class="right">&lt;button id="textDone">Done&lt;/button>&lt;/div>`;
		let fontSizeInput = document.getElementById('fontSize');
		fontSizeInput.value = parseInt(this.font);
		fontSizeInput.focus();
		document.getElementById('fontColor').value = this.fontColor;
		document.getElementById('textDone').addEventListener('click', () => {
			this.font =
				fontSizeInput.value + 'px ' + this.fontFamily(this.font);
			this.fillStyle = document.getElementById('fontColor').value;
			underlay.removeChild(box);
		});
	}
	/**
	 * returns the font-family from a CSS font definitio, e.g. "16px sans-serif"
	 * @param {string} str
	 */
	fontFamily(str) {
		return str.substring(str.indexOf(' ') + 1);
	}
}
let textHandler = new TextHandler();

/* ========================================================== pencil ================================================ */
class PencilHandler extends ToolHandler {
	constructor() {
		super();
	}
	mousemove(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			drawHelper.pencil(tempctx, this.options(), [
				this.startX,
				this.startY,
				this.endX,
				this.endY,
			]);
			this.record();
			this.startX = this.endX;
			this.startY = this.endY;
		}
	}
	mouseup(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			this.record();
			this.isMouseDown = false;
			super.mouseup();
			redraw();
		}
	}
	record() {
		points[points.length] = [
			'pencil',
			this.options(),
			[this.startX, this.startY, this.endX, this.endY],
		];
	}
	optionsDialog() {
		let box = super.optionsDialog('pencil');
		box.innerHTML = `
		&lt;div>Width&lt;/div>&lt;div>&lt;input id="pencilWidth" type="text" size="2">&lt;/div>
		&lt;div>Colour&lt;/div>&lt;div>&lt;input id="pencilColor" type="color">&lt;/div>
		&lt;div>&lt;/div>&lt;div class="right">&lt;button id="pencilDone">Done&lt;/button>&lt;/div>`;
		let widthInput = document.getElementById('pencilWidth');
		widthInput.value = this.lineWidth;
		widthInput.focus();
		document.getElementById('pencilColor').value = this.strokeStyle;
		document.getElementById('pencilDone').addEventListener('click', () => {
			this.lineWidth = parseInt(widthInput.value);
			this.strokeStyle = document.getElementById('pencilColor').value;
			underlay.removeChild(box);
		});
	}
}
let pencilHandler = new PencilHandler();

/* ========================================================== marker ================================================ */
class MarkerHandler extends ToolHandler {
	constructor() {
		super();
		this.globalAlpha = 0.2;
		this.globalCompositeOperation = 'source-over';
		this.strokeStyle = '#ffff00';
		this.lineWidth = 30;
	}
	mousemove(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			drawHelper.marker(tempctx, this.options(), [
				this.startX,
				this.startY,
				this.endX,
				this.endY,
			]);
			this.record();
			this.startX = this.endX;
			this.startY = this.endY;
		}
	}
	mouseup(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			this.record();
			this.isMouseDown = false;
			super.mouseup();
			redraw();
		}
	}
	record() {
		points[points.length] = [
			'marker',
			this.options(),
			[this.startX, this.startY, this.endX, this.endY],
		];
	}
	optionsDialog() {
		let box = super.optionsDialog('marker');
		box.innerHTML = `
		&lt;div>Width&lt;/div>&lt;div>&lt;input id="markerWidth" type="text" size="2">&lt;/div>
		&lt;div>Colour&lt;/div>&lt;div>&lt;input id="markerColor" type="color">&lt;/div>
		&lt;div>&lt;/div>&lt;div class="right">&lt;button id="markerDone">Done&lt;/button>&lt;/div>`;
		let widthInput = document.getElementById('markerWidth');
		widthInput.value = this.lineWidth;
		widthInput.focus();
		document.getElementById('markerColor').value = this.strokeStyle;
		document.getElementById('markerDone').addEventListener('click', () => {
			this.lineWidth = parseInt(widthInput.value);
			this.strokeStyle = document.getElementById('markerColor').value;
			underlay.removeChild(box);
		});
	}
}
let markerHandler = new MarkerHandler();

/* ========================================================== eraser ================================================ */
/* the same as a marker, but with white ink and a special, bespoke cursor */

class EraserHandler extends ToolHandler {
	constructor() {
		super();
		this.strokeStyle = '#ffffff';
		this.lineWidth = 30;
	}
	mousedown(e) {
		super.mousedown(e);
		underlay.style.cursor = 'none';
	}
	mousemove(e) {
		if (this.isMouseDown) {
			this.cursor('#ffffff', 1);
			this.endPosition(e);
			drawHelper.marker(tempctx, this.options(), [
				this.startX,
				this.startY,
				this.endX,
				this.endY,
			]);
			this.record();
			this.startX = this.endX;
			this.startY = this.endY;
			this.cursor('#000000', 2);
		}
	}
	/**
	 * draw a circle at the mouse to simulate a cursor
	 * @param {string} color - as hex 
	 * @param {integer} width 
	 */
	cursor(color, width) {
		tempctx.beginPath();
		tempctx.arc(
			this.startX,
			this.startY,
			Math.round(this.lineWidth / 2 - width),
			0,
			2 * Math.PI
		);
		tempctx.strokeStyle = color;
		tempctx.lineWidth = width;
		tempctx.stroke();
	}
	mouseup(e) {
		if (this.isMouseDown) {
			this.endPosition(e);
			this.record();
			this.isMouseDown = false;
			super.mouseup();
			redraw();
			underlay.style.cursor = 'auto';
		}
	}
	record() {
		points[points.length] = [
			'marker',
			this.options(),
			[this.startX, this.startY, this.endX, this.endY],
		];
	}
	optionsDialog() {
		let box = super.optionsDialog('eraser');
		box.innerHTML = `
		&lt;div>Width&lt;/div>&lt;div>&lt;input id="eraserWidth" type="text" size="2">&lt;/div>
		&lt;div>&lt;/div>&lt;div class="right">&lt;button id="eraserDone">Done&lt;/button>&lt;/div>`;
		let widthInput = document.getElementById('eraserWidth');
		widthInput.value = this.lineWidth;
		widthInput.focus();
		document.getElementById('eraserDone').addEventListener('click', () => {
			this.lineWidth = parseInt(widthInput.value);
			underlay.removeChild(box);
		});
	}
}
let eraserHandler = new EraserHandler();

/* ========================================================== image ================================================ */
class ImageHandler extends ToolHandler {
	constructor() {
		super();
	}
}
let imageHandler = new ImageHandler();

/* ========================================================== undo ================================================ */
class UndoHandler extends ToolHandler {
	constructor() {
		super();
	}
	/**
	 *  starting with the last of the recorded points, delete backwards until the previous 'endShape'
	 *  and then redraw what remains
	 */
	undo() {
		if (points.length == 1) return;
		let i;
		for (i = points.length - 2; i > 0 &amp;&amp; points[i][0] !== 'endShape'; i--);
		points.length = i + 1;
		redraw();
	}
}
let undoHandler = new UndoHandler();

const toolToHandler = {
	line: lineHandler,
	rect: rectHandler,
	text: textHandler,
	pencil: pencilHandler,
	marker: markerHandler,
	eraser: eraserHandler,
	image: imageHandler,
	undo: undoHandler,
};
/**
 * return the correct instance of toolHandler for the given tool
 * @param {string} tool
 */
function toolHandler(tool) {
	return toolToHandler[tool];
}

/**
 * redraw the main canvas, using the stored commands in points[]
 */
function redraw() {
	drawHelper.clear(tempctx);
	drawHelper.clear(mainctx);
	points.forEach((point) => {
		drawHelper[point[0]](mainctx, point[1], point[2]);
	});
}

/**
 * methods to redraw the canvas, one for each tool
 */
let drawHelper = {
	clear: function (ctx) {
		ctx.save();
		// Use the identity matrix while clearing the canvas
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
		// Restore the transform
		ctx.restore();
		ctx.beginPath();
	},
	line: function (ctx, options, [startX, startY, endX, endY]) {
		ctx.beginPath();
		applyOptions(ctx, options);
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
	},
	rect: function (ctx, options, [startX, startY, endX, endY]) {
		ctx.beginPath();
		applyOptions(ctx, options);
		ctx.strokeRect(startX, startY, endX, endY);
		ctx.fillRect(startX, startY, endX, endY);
	},
	text: function (ctx, options, [text, startX, startY]) {
		ctx.beginPath();
		ctx.textBaseline = 'top';
		applyOptions(ctx, options);
		ctx.fillText(text, startX, startY + 3);
	},
	pencil: function (ctx, options, [startX, startY, endX, endY]) {
		ctx.beginPath();
		applyOptions(ctx, options);
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
	},
	marker: function (ctx, options, [startX, startY, endX, endY]) {
		ctx.beginPath();
		applyOptions(ctx, options);
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
	},
	eraser: { /* never called: eraser uses 'marker'*/},
	image: {},
	undo: { /* never called */ },
	endShape: function () { /* noop */ }
};

/**
 * apply the canvas options to the context
 * @param {context} ctx 
 * @param {object} options - object with options as properties
 */

function applyOptions(ctx, options) {
	for (let option in options) ctx[option] = options[option];
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ToolHandler.html">ToolHandler</a></li></ul><h3>Global</h3><ul><li><a href="global.html#applyOptions">applyOptions</a></li><li><a href="global.html#closeOptionsDialogs">closeOptionsDialogs</a></li><li><a href="global.html#drawHelper">drawHelper</a></li><li><a href="global.html#getContext">getContext</a></li><li><a href="global.html#mouseDespatch">mouseDespatch</a></li><li><a href="global.html#redraw">redraw</a></li><li><a href="global.html#selectTool">selectTool</a></li><li><a href="global.html#setUpCanvas">setUpCanvas</a></li><li><a href="global.html#setUpPaint">setUpPaint</a></li><li><a href="global.html#setUpToolbox">setUpToolbox</a></li><li><a href="global.html#toolHandler">toolHandler</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Fri Jun 19 2020 23:28:03 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
